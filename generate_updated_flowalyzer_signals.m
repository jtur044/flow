function eachOutputResultFile = generate_updated_flowalyzer_signals (configfile)

% GENERATE_UPDATED_FLOWALYZER_SIGNALS Generate updated eye signals 
%
%   generate_updated_flowalyzer_signals (configfile)
%
% where 
%       configfile is the configuration file 
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MAIN 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% logging
if (exist(LogFile))
    delete(LogFile);
end
Log('open',LogFile);


%% create a face controller  
if (~exist('FaceInfo','var'))
    FaceInfo = OpenFaceInfoController ();
end

config          = loadjson (configfile); %% default 

%% read a protocol file 
protocolTable = readtable(config.protocol.file);


%figure(1); clf; hold on;
M = length (config.processList);
for k = 1:M  
    
    
    eachProcess    = config.processList{k};
    
    
    if (isfield(eachProcess, 'keep'))
        if (~eachProcess.keep)
            fprintf ('ignoring ... %s\n', eachProcess.input_video);
            continue;
        end
    end
    
    
    [eachPart, eachName, eachExt] = fileparts(eachProcess.input_features);
    
    %% if there is an "eye" field then use it.
    if (isfield(eachProcess, 'eye'))    
        eachInputFile  = fullfile(config.directories.input, config.directories.input_features, eachPart, 'RESULT', eachProcess.eye, 'result.csv');
        outputDirectory      = fullfile(config.directories.package, eachProcess.name, eachProcess.eye);
    else
        eachInputFile  = fullfile(config.directories.input, config.directories.input_features, eachPart, 'RESULT', 'result.csv');
        outputDirectory      = fullfile(config.directories.package, eachProcess.name);        
    end
    
    %% Read Packaged CSV Files and update them 
    eachInputResultFile  = fullfile(outputDirectory, strcat(eachName, '.result.csv'));     
    eachOutputResultFile = fullfile(outputDirectory, strcat(eachName, '.result.updated.csv'));     
        
    
    fprintf ('updating ... %s\n', eachOutputResultFile);
    
    %% get the correct direction from protocol table
    % isFound = (protocolTable.Number == eachProcess.id) & (protocolTable.logMar == eachProcess.logMAR) & (protocolTable.Trial == eachProcess.order); 
    % isFound = (protocolTable.level == eachProcess.level) & (protocolTable.group == eachProcess.group) & (protocolTable.order == eachProcess.order); 


    %% Input table     [ Add the direction field ... if it exists in the protocol file ]
    isFound = (protocolTable.id == eachProcess.id) & (protocolTable.level == eachProcess.level) & (protocolTable.group == eachProcess.group) & (protocolTable.order == eachProcess.order); 
    if (any(isFound))
        y = readtable (eachInputResultFile);                    
        if (ismember('Direction', protocolTable.Properties.VariableNames))                  
            fprintf ('Adding a direction FIELD.\n');
            y.Direction = protocolTable.Direction(isFound) * ones(size(y,1),1);                
        end
        
    else
        error ('couldnt locate');        
    end
    

    total_table = table();
    
    ids = unique(y.Id);    
    for k = 1:length(ids)
    
        %% which rows 
        rows = y.Id == ids(k);
        y0 = y(rows, :);
                
        % Create smoothed SIGNAL data         
        % Decompose Signal using the MODWT
        % Generated by MATLAB(R) 9.7 and Wavelet Toolbox 5.3.
        % Generated on: 17-Dec-2020 20:26:52
        % Logical array for selecting reconstruction elements
                
        M = length(config.filters);
        for l = 1:M        
        
            each_filter = config.filters{l};            
            fprintf ('%d. id = %d, function = %s, updated = %s ', l, ids(k), each_filter.function, each_filter.output);                        
            y0 = dispatch_function (each_filter, y0);   
                        
        end
        
        total_table = [ total_table ; y0 ];
        
        %%% STANDARD UPDATED SIGNAL          
        %[fX, fY, dfXdt, dfYdt] = update_signal (y0, 'finalX','finalY', config.filters);                
        %y.updated_X(rows)  = fX; %y.updatedmissingFlagX(rows) = tfX; 
        %y.updated_Y(rows)  = fY; %y.missingFlagY(rows) = tfY;        
        %y.updated_dXdt(rows) = dfXdt; %y.updatedmissingFlagX(rows) = tfX; 
        %y.updated_dYdt(rows) = dfYdt; %y.missingFlagY(rows) = tfY;
        

        %% STANDARD UPDATED SIGNAL          
        %[fX, fY, dfXdt, dfYdt] = update_signal (y0, 'noseTip_finalX','noseTip_finalY', config.filters);                
        %y.updated_noseTip_X(rows)  = fX; %y.updatedmissingFlagX(rows) = tfX; 
        %y.updated_noseTip_Y(rows)  = fY; %y.missingFlagY(rows) = tfY;        
        %y.updated_noseTip_dXdt(rows) = dfXdt; %y.updatedmissingFlagX(rows) = tfX; 
        %y.updated_noseTip_dYdt(rows) = dfYdt; %y.missingFlagY(rows) = tfY;
                
        %% DERIVATIVE SIGNALS 
        %dudx=derivative_cwt(u,wt_name,wt_scale,dx,trt_flag)
        
    end
    
    %% OutputCOPY RESULT FILE 
    writetable(total_table, eachOutputResultFile);
       
 end

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FILTER DISPATCHER  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% dispatch function 

function y = dispatch_function  (this_filter, y)


    switch (this_filter.function)
       
        case { 'tidy' }

            f = y.(this_filter.input{1});
            n = this_filter.value;
            thicken = this_filter.thicken;
                        
            is_tracking = y.(this_filter.input{2});
            y.(this_filter.output) = tidy (f, n, thicken, ~is_tracking);
            fprintf ('OK\n');


        case { 'detrender' }

            f = y.(this_filter.input{2});
            t = y.(this_filter.input{1});

            poly_order   = this_filter.value(1);
            min_duration = this_filter.value(2);
            y.(this_filter.output) = detrender (t, f, poly_order, min_duration);
            fprintf ('OK\n');

        case { 'gradient' }

            f = y.(this_filter.input{2});
            t = y.(this_filter.input{1});
            y.(this_filter.output) = grad (f, t);
            fprintf ('OK\n');
            
        otherwise            
            fprintf ('NOT FOUND\n');
            
            
    end

end




%% tidy - adds nans and medfilter
function f = tidy (f, npoint, n_thicken, is_deleted)

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %
        % n_point is [ front/back, mask, median filter, expand times ]
        %
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %% put empty on the front and back  
        f(is_deleted) = nan;
        f = cleanSignal(f, npoint(1));  
        
        %% expand and connect small regions   
        mask = isnan (f);
        
        %% remove additional information around borders assuming there will be edge effects         
        for k = 1:n_thicken
            mask = logical(conv(mask, logical([ 1 1 1 ]), 'same'));
        end
                
        %% fill in borders assuming there will be edge effects                 
        mask = imfill(mask, [ npoint(2) 1  ]);
        f(mask) = nan;
        
        %% median filter and signal reset
        f = medfilt1(f, npoint(3));
        f = signalReset (f);
        
        
end

function f1 = detrender (t, f, poly_order, min_duration)


    %% create regions 
    labels = ~isnan(f);
    bp     = diff(labels);
    bp_start = find (bp > 0) + 1;
    bp_end   = find (bp < 0);

    if (isfinite(f(1)))
        bp_start = [ 1 ; bp_start ];
    end

    if (isfinite(f(end)))
        bp_end = [ bp_end ; length(f) ];
    end


    %% time regions 

    f1 = nan*f;

    M = length(bp_start);
    for k = 1:M

        t_start = t(bp_start(k));    
        t_end   = t(bp_end(k));

        t_duration = t_end - t_start;
        if  (t_duration > min_duration)  %% only keep regions greater than 1 second

            %% show detrended 
            t0 = t(bp_start(k):bp_end(k));
            x0 = f(bp_start(k):bp_end(k));
            x1 = detrend (x0, poly_order, 'omitnan');

            %% detrended 
            f1(bp_start(k):bp_end(k)) = x1 - x1(1); 

        end 

    end
end


function dfdt = grad (f, t)

        %% ignore first 10 samples and last 10 samples  
        df  = gradient (f);
        dt  = gradient(t);
        dfdt = df./dt;
end


%{ 
function [fX, fY, dfXdt, dfYdt] = update_signal (y0, which_x_field, which_y_field, filter)

    
        which_time_field = 'currentTime';
    
        t = y0.(which_time_field);
        
        %% ignore first 10 samples and last 10 samples  
        N  = 10;
        fX = cleanSignal(y0.finalX, N);
        fY = cleanSignal(y0.finalY, N);
        
        %% Add a raw derivative column 
        %dfXdt_raw = gradient(fX)./gradient(t);
        %dfYdt_raw = gradient(fY)./gradient(t);        
        %y.final_dXdt(rows) = dfXdt_raw; 
        %y.final_dYdt(rows) = dfYdt_raw; 
                
        %% do updates (OPENFACE) fill it in 
        [fX, tfX] = fillmissing(fX, 'linear','SamplePoints', t);
        [fY, tfY] = fillmissing(fY, 'linear','SamplePoints', t);
        
                      
        %% apply the specified filter 
        [fX, fY] = feval(filter, fX, fY);
                
        %% PUT MISSING DATA BACK
        fX(tfX) = nan; fX = fX(:);
        fY(tfY) = nan; fY = fY(:);

        %% NUMERICAL GRADIENTS        
        dfXdt = gradient(fX)./gradient(t);
        dfYdt = gradient(fY)./gradient(t);
                       
        %% RESET SIGNAL ON MAIN SIGNAL 
        fX = signalReset(fX);
        fY = signalReset(fY);
               

end
%}
